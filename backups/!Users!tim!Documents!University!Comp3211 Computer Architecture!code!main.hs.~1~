module Main where

import System.Environment
import Text.ParserCombinators.Parsec hiding (spaces)
import Data.Char

data AsmVal = Register Integer                     |
              Immediate String                     |
              Operation String                     |
              I_Type String AsmVal AsmVal          |                           
              R_Type1 AsmVal AsmVal                |
              R_Type2 AsmVal AsmVal AsmVal         |
              R_Type3 AsmVal AsmVal AsmVal AsmVal

parseRegister :: Parser AsmVal
parseRegister = do string "$r"
                   x <- oneOf (['0','1'..'7'])
                   return $ Register (digitToInt x)

parseImmediate :: Parser AsmVal
parseImmediate = do s <- string "0x"
                    x1 <- oneOf (['0','1'..'9'] ++ ['A','B'..'F'] ++ ['a','b'..'f'])
                    x2 <- oneOf (['0','1'..'9'] ++ ['A','B'..'F'] ++ ['a','b'..'f'])
                    return $ Immediate s ++ x1 ++ x2

parseIType :: Parser AsmVal
parseIType = do s <- string "li"
                rs <- parseRegister
                string ", "
                imm <- parseImmediate
                return $ I_Type s rs imm

parseOperation :: Parser AsmVal
parseOperation = do op <- string "xor"
                       <|> string "add"
                       <|> string "lsr"
                       <|> string "lsl"
                       <|> string "ldr"
                       <|> string "ldx"
                       <|> string "str"
                    return $ Operation op

parseR3Type :: Parser AsmVal
parseR3Type = do op <- parseOperation
                 string " "
                 rs <- parseRegister
                 string ", "
                 rt <- parseRegister
                 string ", "
                 rd <- parseRegister
                 return $ R_Type3 op rs rt rd

parseR2Type :: Parser AsmVal
parseR2Type = do op <- parseOperation
                 string " "
                 rs <- parseRegister
                 string ", "
                 rt <- parseRegister
                 return $ R_Type2 op rs rt

parseRType :: Parser AsmVal
parseRType = do op <- parseOperation
                string " "
                rs <- parseRegister
                return $ R_Type1 op rs

parseBlock :: Parser AsmVal
parseBlock = parseIType
           <|> parseR3Type
           <|> parseR2Type
           <|> parseRType

readExpr :: String -> String
readExpr input = case parse parseBlock "asm" input of
         Left err -> "No match: " ++ show err
         Right val -> "Found value: " ++ show val

main :: IO ()
main = do args <- getArgs
          putStrLn( readExpr (args !! 0))