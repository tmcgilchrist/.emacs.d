-- Build a library that adds a class method called build() to Regexp. 
-- build() should accept a variable number of arguments which can include 
-- integers and ranges of integers. Have build() return a Regexp object 
-- that will match only integers in the set of passed arguments.

-- Problems:
-- 1. Regex construction see 
--    http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/

-- 2. 
import List
import Text.Regex.Posix
import Data.Char

-- Prelude> :mod +Text.Regex.Posix
-- Prelude Text.Regex.Posix> "bar" =~"(foo|bar)" :: Bool
-- True

-- Prelude Text.Regex.Posix> "adliubfs" =~"(foo|bar)" :: Bool
-- False
match input =
    foldl (++) "" (proc input)

proc input =
    map (\x -> [(intToDigit x)] ++ "|") (sort (concat input))

test input =
    (sort (concat input))
    
myLast :: [a] -> a
myLast [x] = x
myLast (x:xs) = myLast xs

myLastBut :: [a] -> a
myLastBut x = head (tail (reverse x))

elementAt :: [a] -> Int -> a
elementAt (x:xs) 1 = x
elementAt (x:xs) b = elementAt xs (b-1)

myLength :: [a] -> Int
myLength [] = 0
myLength (x:xs) = 1 + myLength(xs)

myLengthFold :: [a] -> Int
myLengthFold = foldr (\x n -> n + 1) 0

myReverse :: [a] -> [a]
myReverse [] = []
myReverse (x:xs) = myReverse xs ++ [x]

isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome [] = False
isPalindrome xs = xs == (reverse xs)

-- Problem 7
myFlatten :: [a] -> [a]
myFlatten [] = []
myFlatten (x:xs) =
    case isList x
         (myFlatten x) ++ (myFlatten xs)

-- how do we perform a case statement?
