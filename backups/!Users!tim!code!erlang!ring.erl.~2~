-module(ring).
-compile(export_all).
-import(lists, [foreach/2, map/2, reverse/1]).

%%% Write a ring benchmark. Create N processes in a ring. Send a 
%%% message round the ring M times so that a total of N*M messages 
%%% get sent. Time how long this takes for differnt values of N and M.

%%% Write a similar program in some other language you are familar with.
%%% Compare the results. Write a blog, and publish the results on the Internet!
main([A,B]) ->
    N = list_to_integer(A),
    M = list_to_integer(B),
    io:format("~w: ~w processes with ~w messages\n", [self(), N, M]),
    % Spawn 'N' processes and link them together.
    [First|_] = Pids = for(1, N, fun() -> spawn(fun() -> loop() end) end),
    setupLoop(Pids),

    % Start sending messages.
    sendMsgs(M, First),

    % Cleanup!!
    map(fun(P) -> P ! {exit} end, Pids).

setupLoop([P]) ->
    P ! {next, self()};
setupLoop([P1,P2|Rest]) ->
    P1 ! {next, P2},
    setupLoop([P2|Rest]).

sendMsgs(0, First) ->
    First ! {relay},
    receive
        {relay} ->
            io:format("~w: Finished ~w loops.~n", [self(), 0])
    end;
sendMsgs(N, First) ->
    First ! {relay},
    receive
        {relay} ->
            sendMsgs(N-1, First)
    end.

loop() ->
    io:format("~w: Starting node~w~n", [self(), self()]),
    receive
        {next, Pid} ->
            loop(Pid);
        {exit} ->
            io:format("~w: Exiting now! ~n", [self()])
    end.

loop(Pid) ->
    receive
        {relay} ->
            Pid ! {relay},
            loop(Pid);
        {exit} ->
            io:format("~w: Exiting now!~n", [self()])
    end.

for(N, N, F) ->
     [F()];
for(I, N, F) -> 
    [F() | for (I+1, N, F)].

    
