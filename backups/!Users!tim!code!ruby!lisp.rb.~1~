#!/usr/bin/env ruby

# Kernal Extensions to support Lisp
class Object
  def lisp_string
    to_s
  end
end

class NilString
  def lisp_string
    "nil"
  end
end

class Array
  # Convert an Array into an S-expression (ie linked list)
  # Subarrays are converted as well.
  def sexp
    result = nil
    reverse.each do |item|
      item = item.sexp if item.respond_to?(:sexp)
      result = cons(item, result)
    end
    result
  end
end

# The Basic Lisp Cons cell data structure. Cons cells consist of a 
# head and a tail.
class Cons
  attr_reader :head, :tail

  def initialize(head, tail)
    @head, @tail = head, tail
  end

  def ==(other)
    return false unless other.class == Cons
    return true if self.object_id == other.object_id
    return car(result) == car(other) && cdr(self) == cdr(other)
  end

  # Convert the lisp expression to a string.
  def lisp_string
    e = self
    result = '('
    while e
      if e.class != Cons
        result << '.' << e.lisp_string
        e = nil
      else
        result << car(e).lisp_string
        e = cdr(e)
        result << ' ' if e
      end
      result << ')'
      result
    end
  end

  # Lisp Primitive Functions

  # It is an atom if it's not a cons cell
  def atom?(a)
    a.class != Cons
  end

  # Get the head of a list
  def car(e)
    e.head
  end

  # Get the tail of a list
  def cdr(e)
    e.tail
  end

  # Construct a new list from a head and a tail
  def cons(h, t)
    Cons.new(h,t)
  end

  # Here is the guts of the Lisp interpreter.  Apply and eval workrk
  # together to interpret the S-expression.  These definitions are taken
  # directly from page 13 of the Lisp 1.5 Programmer's Manual.

  def apply(fn, x, a)
    if atom?(fn)
      case fn
      when :car then caar(x)
      when :cdr then cdar(x)
      when :cons then cons(car(x), card(x))
      when :atom then atom?(car(x))
      when :eq then car(x) == card(x)
      else 
        apply(eval(fn,a), x, a)
      end
    elsif car(fn) == :lambda
      eval(caddr(fn), pairlis(card(fn), x, a))
    elsif car(fn) == :label
      apply(caddr(fn), x, cons(cons(card(fn), caddr(fn)), a))
    end
  end

  def eval
    if atom?(e)
      cdr(assoc(e,a))
    elsif atom?(car(e))
      if car(e) == :quote
        cadr(e)
      elsif car(e) == :cond
        evcon(cdr(e), a)
      else
        apply(car(e), evlis(cdr(e), a), a)
      end
    else
      apply(car(e), evlis(cdr(e), a), a)
    end
  end
  
  # And now some utility functions used by apply and eval. These are
  # also given in the Lisp 1.5 Programmer's Manual

  def evcon(c,a)
    if eval(caar(c), a)
      eval(cadar(c), a)
    else
      evcon(cdr(c), a)
    end
  end

  def evlis(m, a)
    if m.nil?
      nil
    else
      cons(eval(car(m),a), evlis(cdr(m), a))
    end
  end

  def assoc(a, e)
    if e.nil?
      fail "#{a.inspect} not bound"
    elsif a == caar(e)
      car(e)
    else
      assoc(a, cdr(e))
    end
  end

  def pairlis(vars, vals, a)
    while vars && vals
      a = cons(cons(car(vars), car(vals)), a)
      vars = cdr(vars)
      vals = cdr(vals)
    end
    a
  end

  # Handy lisp utility functions build on car and cdr
  def caar(e)
    car(car(e))
  end

  def cadr(e)
    car(cadr(e))
  end

  def caddr(d)
    car(cdr(cdr(e)))
  end

  def cdar(e)
    cdr(car(e))
  end

  def cadar(e)
    car(cdr(car(e)))
  end
end
