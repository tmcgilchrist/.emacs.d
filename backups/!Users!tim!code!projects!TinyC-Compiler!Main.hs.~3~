module Main where

import System.Environment
import Text.ParserCombinators.Parsec hiding (spaces)

data CVal = Number Integer
          | Identifier Char
          | Operator String
          | Term CVal
          | IfStmt CVal CVal
          | IfElseStmt CVal CVal CVal
          | WhileStmt CVal CVal
          | DoWhileStmt CVal CVal 
          | BlockStmt CVal              -- holds variable scope
          | EmptyStmt
          deriving (Show)
-- instance Show CVal where show = showVal

-- TODO Customise Show function.

showVal :: CVal -> String
showVal (Number contents) = show contents
showVal (Identifier contents) = show contents
showVal (Operator contents) = show contents
showVal (IfStmt paren stmt) = "if " ++ show paren ++ " " ++ show stmt
showVal (IfElseStmt paren istmt estmt) = "if " ++ show paren ++ show istmt ++" else " ++ show estmt
showVal (WhileStmt paren stmt) = "while " ++ show paren ++ " " ++ show stmt 

spaces :: Parser ()
spaces = skipMany space

parseIdentifier :: Parser CVal
parseIdentifier = do x <- oneOf (['a','b'..'z'])
                     return $ Identifier x

parseNumber :: Parser CVal
parseNumber = do x <- many1 digit
                 (return . Number . read) x

parseTerm :: Parser CVal
parseTerm = parseIdentifier
          <|> parseNumber
          <|> parseParenExpr
          <?> "Expecting <term> ::= <id> | <int> | <paren_expr>"

-- Requires Left Factoring

parseParenExpr :: Parser CVal
parseParenExpr = do char '('
                    spaces
                    x <- parseExpr
                    spaces
                    char ')'
                    return $ x

parseExpr :: Parser CVal
parseExpr = parseIdentifier
          <|> parseNumber
          <|> parseParenExpr
          <|> parseTerm

parseIfStmt :: Parser CVal
parseIfStmt = do string "if"; spaces
                 y <- parseParenExpr; spaces
                 z <- parseExpr; spaces
                 parseElse y z <|> (return $ IfStmt y z)

parseElse :: CVal -> CVal -> Parser CVal
parseElse a b = do try $ string "else"; spaces
                   y <- parseExpr; spaces
                   return $ IfElseStmt a b y

parseWhileStmt ::  Parser CVal
parseWhileStmt = do string "while"; spaces
                    y <- parseParenExpr; spaces
                    z <- parseExpr; spaces
                    return $ WhileStmt y z

parseDoWhileStmt :: Parser CVal
parseDoWhileStmt = do string "do"; spaces
                      y <- parseExpr; spaces
                      string "while"; spaces
                      z <- parseParenExpr;
                      string ";"; spaces
                      return $ DoWhileStmt y z

parseBlockStmt :: Parser CVal
parseBlockStmt = do char '{'; spaces
                    y <- parseStatement
                    char '}'
                    return $ BlockStmt y

parseExprStmt :: Parser CVal
parseExprStmt = do y <- parseExpr
                   char ';'
                   return $ y

parseEmptyStmt :: Parser CVal
parseEmptyStmt = do char ';'
                    return $ EmptyStmt

parseStatement :: Parser CVal
parseStatement = parseIfStmt
               <|> parseWhileStmt
               <|> parseDoWhileStmt
               <|> parseEmptyStmt
               <|> parseBlockStmt

readExpr :: String -> String
readExpr input = case parse parseStatement "tinyC" input of
    Left err -> "No match: " ++ show err
    Right val -> "Found value: " ++ show val

main :: IO ()
main = do args <- getArgs
          putStrLn( readExpr (args !! 0))