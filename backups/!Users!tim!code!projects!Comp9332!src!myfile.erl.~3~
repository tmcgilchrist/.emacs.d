-module(myfile).
-author('Tim McGilchrist').
-compile(export_all).
% 1. Read all lines of file into memory.
% 
% List = myfile:start().
start() ->
    FileName = "../Question1/3128676.data",
    List = myfile:readlines(FileName),
    SplitList = lists:map(fun(X) -> myfile:split_csv(X) end, List),
    TrimList = lists:map(fun(X) -> myfile:strip_newline(X) end, SplitList),
    lists:sort(fun(A,B) -> myfile:sort_time(A,B) end, TrimList).

readlines(FileName) ->
    {ok, Device} = file:open(FileName, [read]),
    get_all_lines(Device, []).

get_all_lines(Device, Accum) ->
    case io:get_line(Device, "") of
        eof  -> file:close(Device), Accum;
        Line -> get_all_lines(Device, Accum ++ [Line])
    end.

% 2. Split each line on comma. 
% SplitList = lists:map(fun(X) -> myfile:split_csv(X) end, List).
%
% Split a comma separated string
% re:split("324-0-A0907,0934,4860,2384","[,]",[{return,list}]).
split_csv(X) ->
    re:split(X,"[,]",[{return,list}]).

% 2.1 Remove whitespace from lines.
% Strips any whitespace characters from end of Str
% TrimList = lists:map(fun(X) -> myfile:strip_newline(X) end, SplitList).
strip_newline([A,B,C,Str]) ->
    [A,B,C,re:replace(Str, "\\s+", "", [{return,list}])].


% 3. Sort List according to second element (time).
% SortList = lists:sort(fun(A,B) -> myfile:sort_time(A,B) end, TrimList).
sort_time(A, B) ->
    [_,T1,_,_] = A,
    [_,T2,_,_] = B,
    T1 < T2.

% 4. For each group with same time value,
%    calculate Euclidian distance 
euclidean_dist(A, B) ->
    [_,_,P1,P2] = A,
    [_,_,Q1,Q2] = B,
    math:sqrt(math:pow(list_to_integer(P1) - list_to_integer(Q1), 2) +
              math:pow(list_to_integer(P2) - list_to_integer(Q2), 2)).

% Split list into chunks with same Time
% CompList = myfile:comp(myfile:start()).
comp(List) ->
    [[_,Key0,_,_]|_] = List,
    comp0(List, Key0, []).

comp0(List, Key, Accum) ->                  
    {First,Rest} = lists:splitwith(fun([_,X,_,_]) -> string:equal(X, Key) end, List),
    Accum0 = [First] ++ Accum,
    case Rest of 
        [] -> 
            lists:reverse(Accum0); 
        _ ->
            [[_,Key0,_,_]|_] = Rest,
            comp0(Rest, Key0, Accum0)
    end.

    
% Calculate distance between each node and every other node.
% Write results to file "question1.data"
% lists:nth(1,CompList).
%[["389-0-C0845","0900","4404","1783"],
% ["308-1-E0900","0900","2644","3688"],
% ["339-0-A0841","0900","3749","1078"],
% ["413-0-A0815","0900","2247","1668"],
% ["422-1-E0853","0900","2799","3099"],
% ["311-1-F0900","0900","2720","3627"],
% ["327-1-J0858","0900","2778","3530"],
% ["412-0-A0750","0900","2108","1564"]]
%
 
% 8 C 2 is 8! / 2! (8-2) ! = 28
% myfile:comb(lists:nth(1,CompList), []).
comb(List, Acculm) ->
    [[Bus1,_,_,_]|Rest] = List,
    case Rest of 
        [] -> 
            Accum;
        _ ->
            Accum0 = comb0(Bus1, Rest, []) ++ Accum,
            comb(Rest, Accum0)
    end.

comb0(Bus, List, Accum) ->
    [[Bus1,_,_,_]|Rest] = List,
    Accum0 =  [[Bus, Bus1]] ++ Accum,
    case Rest of 
        [] ->
            lists:reverse(Accum0);
        _ ->
            comb0(Bus, Rest, Accum0)
    end.

% Want something like this lists:map(CompList, fun(X) -> myfile:comb(X, [])).
% Map comb across 
